Instructions using : https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PART I %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
First, create a virtual environment in the project directory:

==============================================================================
++++
# cd to project directory. (Make directory if you need to)
#Powershell:
$ New-Item c:\PATH\[DIRECTORY NAME] -type directory
#Mac Terminal:
$ mkdir [Directory Name]
#OR (for multiple)
$ mkdir -p parentdir/childdir/etc

#Create the virtual environment
$ virtualenv [new virtual environment directory name]
++++
==============================================================================



The reason for this is to  create a folder in the current directory which will
  contain the Python executable files, and a copy of the pip library which you
  can use to install other packages. The name of the virtual environment (in
  this case, it was my_project) can be anything; omitting the name will place
  the files in the current directory instead.

Virtual env: http://python-guide-pt-br.readthedocs.io/en/latest/dev/virtualenvs/

Next, activate the virtual environment:

NOTE: in Powershell, you may have to run it as an administrator and use:
$ set-executionpolicy RemoteSigned
to allow it to run scripts.


==============================================================================
++++
#Powershell:
$ [new virtual environment directory name]/Scripts/activate.ps1
#Terminal
$ source [new virtual environment directory name]/bin/activate
++++
==============================================================================

NOTE: To deactivate the virtualenv, type:
$ deactivate


If you are on Linux, OS X or Cygwin, install flask and extensions by entering the following commands, one after another:

==============================================================================
++++
$ pip install flask
$ pip install flask-login
$ pip install flask-openid
$ pip install flask-mail
$ pip install flask-sqlalchemy
$ pip install sqlalchemy-migrate
$ pip install flask-whooshalchemy
$ pip install flask-wtf
$ pip install flask-babel
$ pip install guess_language
$ pip install flipflop
$ pip install coverage
++++
==============================================================================

If you are on Windows the commands are slightly different:
==============================================================================
++++
$ py -m pip install flask
$ py -m pip install flask-login
$ py -m pip install flask-openid
$ py -m pip install flask-mail
$ py -m pip install flask-sqlalchemy
$ py -m pip install sqlalchemy-migrate
$ py -m pip install flask-whooshalchemy
$ py -m pip install flask-wtf
$ py -m pip install flask-babel
$ py -m pip install guess_language
$ py -m pip install flipflop
$ py -m pip install coverage
++++
==============================================================================
These commands will download and install all the packages that we will use for
  our application.


You now have a sub-folder inside your microblog folder that is populated
  with a Python interpreter and the Flask framework and extensions that we will
  use for this application.

Now it's a good idea to create a "requirements.txt" file with all the
  requirements of your virtual environment.
==============================================================================
++++
#Powershell: create File
$ py -3 -m pip freeze > requirements.txt
#Terminal: create File
$ python3 -m pip freeze > requirements.txt
++++
==============================================================================

NOTE: if you are using another computer as well, perhaps with git, you can now
  use the requirements.txt file to create an identical virtual environment:

First, create a virtual environment like above, activate it, and run this:

==============================================================================
++++
$ pip install -r requirements.txt
++++
==============================================================================


Now, if using git, go into the .gitignore file in your root git directory and
  add the virtual environment directory like this:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++++
/[PATH to env directory from git root]/
++++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For example, mine currently looks like this:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++++
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class
/FlaskMEGATutorial/Env/            <-- here it is
++++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This makes it so that git will not track the virtual environment folder. All
  anyone should need is the requirements.txt file anyway. It's inefficient to
  send someone an entire installation of python and the libraries anyway. Also,
  it won't work across operating systems.

Now it's time to write our first web application!

Now make some more directories in your application directory:
==============================================================================
++++
#Mac Terminal example:
$ mkdir app
$ mkdir app/static
$ mkdir app/templates
$ mkdir tmp

#Powershell example:
$ New-Item PATH\[APP DIRECTORY NAME]\app\static -type directory
$ New-Item PATH\[APP DIRECTORY NAME]\app\templates -type directory
$ New-Item PATH\tmp -type directory
++++
==============================================================================

The app folder will be where we will put our application package. The static
  sub-folder is where we will store static files like images, javascripts, and
  cascading style sheets. The templates sub-folder is obviously where our
  templates will go.


Now create a simple __init__ script for the app package (app/__init__.py). It
  should look like this:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++++
from flask import Flask

app = Flask(__name__)
from app import views
++++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The script above simply creates the application object (of class Flask) and
  then imports the views module, which we haven't written yet. Do not confuse
  app the variable (which gets assigned the Flask instance) with app the
  package (from which we import the views module).

If you are wondering why the import statement is at the end and not at the
  beginning of the script as it is always done, the reason is to avoid circular
  references, because you are going to see that the views module needs to
  import the app variable defined in this script. Putting the import at the end
  avoids the circular import error.

The views are the handlers that respond to requests from web browsers or other
clients. In Flask handlers are written as Python functions. Each view function
is mapped to one or more request URLs.

Let's write our first view function (file app/views.py):
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++++
from app import app

@app.route('/')
@app.route('/index')
def index():
    return "Hello, World!"
++++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This view is actually pretty simple, it just returns a string, to be displayed
  on the client's web browser. The two route decorators above the function
  create the mappings from URLs / and /index to this function.

The final step to have a fully working web application is to create a script
  that starts up the development web server with our application. Let's call
  this script run.py, and put it in the root folder:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++++
#!flask/bin/python
from app import app
app.run(debug=True)
++++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The script simply imports the app variable from our app package and invokes its
  run method to start the server. Remember that the app variable holds the
  Flask instance that we created it above.

To start the app you just run this script. On OS X, Linux and Cygwin you have
  to indicate that this is an executable file before you can run it:

NOTE: haven't tried this. Not sure it's necessary. Could maybe run it the same
  way as windows? In virtual environment, call python [script].py?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++++
$ chmod a+x run.py
#Then the script can simply be executed as follows:
$ ./run.py
++++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

On Windows the process is a bit different. There is no need to indicate the
  file is executable. Instead you have to run the script as an argument to the
  Python interpreter from the virtual environment:

==============================================================================
++++
#Within the virtualenv...
$ py -3 run.py
++++
==============================================================================

After the server initializes it will listen on port 5000 waiting for
  connections. Now open up your web browser and enter the following URL in the
  address field:
http://localhost:5000 OR http://localhost:5000/index

Ctrl-C to quit.






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PART II %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We want the home page of our microblogging app to have a heading that welcomes
  the logged in user, that's pretty standard for applications of this kind.
  Ignore for now the fact that we have no way to log a user in, I'll present a
  workaround for this issue in a moment.

An easy option to output a nice and big heading would be to change our view
  function to output HTML, maybe something like this:

In views.py:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++++
from app import app

@app.route('/')
@app.route('/index')
def index():
    user = {'nickname': 'Miguel'}  # fake user
    return '''
<html>
  <head>
    <title>Home Page</title>
  </head>
  <body>
    <h1>Hello, ''' + user['nickname'] + '''</h1>
  </body>
</html>
'''
++++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Since we don't have support for users yet I have resorted to using a
  placeholder user object, sometimes called fake or mock object. This allows us
  to concentrate on certain aspects of our application that depend on parts of
  the system that haven't been built yet.

Consider how complex the code will become if you have to return a large and
  complex HTML page with lots of dynamic content. And what if you need to
  change the layout of your web site in a large app that has dozens of views,
  each returning HTML directly? This is clearly not a scalable option.

If you could keep the logic of your application separate from the layout or
  presentation of your web pages things would be much better organized, don't
  you think? You could even hire a web designer to create a killer web site
  while you code the site's behaviors in Python. Templates help implement this
  separation.

Let's write our first template (file app/templates/index.html):
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++++
<html>
  <head>
    <title>{{ title }} - microblog</title>
  </head>
  <body>
      <h1>Hello, {{ user.nickname }}!</h1>
  </body>
</html>
++++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


As you see above, we just wrote a mostly standard HTML page, with the only
  difference that there are some placeholders for the dynamic content enclosed
  in {{ ... }} sections.

Now let's see how we use this template from our view function
  (file app/views.py):

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++++
from flask import render_template
from app import app

@app.route('/')
@app.route('/index')
def index():
    user = {'nickname': 'Miguel'}  # fake user
    return render_template('index.html',
                           title='Home',
                           user=user)
++++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To render the template we had to import a new function from the Flask framework
  called render_template. This function takes a template filename and a
  variable list of template arguments and returns the rendered template, with
  all the arguments replaced.

Under the covers, the render_template function invokes the Jinja2 templating
  engine that is part of the Flask framework. Jinja2 substitutes {{...}} blocks
  with the corresponding values provided as template arguments.

Control statements in templates

The Jinja2 templates also support control statements, given inside {%...%}
  blocks. Let's add an if statement to our template
  (file app/templates/index.html):

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++++
from flask import render_template
from app import app

@app.route('/')
@app.route('/index')
def index():
    user = {'nickname': 'Miguel'}  # fake user
    return render_template('index.html',
                           title='Home',
                           user=user)
++++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Control statements in templates

The Jinja2 templates also support control statements, given inside {%...%}
  blocks. Let's add an if statement to our template
  (file app/templates/index.html):

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++++
<html>
  <head>
    {% if title %}
    <title>{{ title }} - microblog</title>
    {% else %}
    <title>Welcome to microblog</title>
    {% endif %}
  </head>
  <body>
      <h1>Hello, {{ user.nickname }}!</h1>
  </body>
</html>
++++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now our template is a bit smarter. If the view function forgets to define a
  page title then instead of showing an empty title the template will provide
  its own title. Feel free to remove the title argument in the render_template
  call of our view function to see how the conditional statement works.


Loops in templates

The logged in user in our microblog application will probably want to see
  recent posts from followed users in the home page, so let's see how we can
  do that.

To begin, we use our handy fake object trick to create some users and some
  posts to show (file app/views.py):

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++++
def index():
    user = {'nickname': 'Miguel'}  # fake user
    posts = [  # fake array of posts
        {
            'author': {'nickname': 'John'},
            'body': 'Beautiful day in Portland!'
        },
        {
            'author': {'nickname': 'Susan'},
            'body': 'The Avengers movie was so cool!'
        }
    ]
    return render_template("index.html",
                           title='Home',
                           user=user,
                           posts=posts)
++++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To represent user posts we are using a list, where each element has author and
  body fields. When we get to implement a real database we will preserve these
  field names, so we can design and test our template using the fake objects
  without having to worry about updating it when we move to a database.

On the template side we have to solve a new problem. The list can have any
  number of elements, it will be up to the view function to decide how many
  posts need to be presented. The template cannot make any assumptions about
  the number of posts, so it needs to be prepared to render as many posts as
  the view sends.

So let's see how we do this using a for control structure
  (file app/templates/index.html):

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++++
<html>
  <head>
    {% if title %}
    <title>{{ title }} - microblog</title>
    {% else %}
    <title>Welcome to microblog</title>
    {% endif %}
  </head>
  <body>
    <h1>Hi, {{ user.nickname }}!</h1>
    {% for post in posts %}
    <div><p>{{ post.author.nickname }} says: <b>{{ post.body }}</b></p></div>
    {% endfor %}
  </body>
</html>
++++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Template inheritance

We have one more topic to cover.

Our microblog web application will need to have a navigation bar at the top of
  the page with a few links. Here you will get the link to edit your profile,
  to login, logout, etc.

We can add a navigation bar to our index.html template, but as our application
  grows we will be needing to implement more pages, and this navigation bar
  will have to be copied to all of them. Then you will have to keep all these
  identical copies of the navigation bar in sync, and that could become a lot
  of work if you have a lot of pages and templates.

Instead, we can use Jinja2's template inheritance feature, which allows us to
  move the parts of the page layout that are common to all templates and put
  them in a base template from which all other templates are derived.

So let's define a base template that includes the navigation bar and also the
  bit of title logic we implemented earlier (file app/templates/base.html):

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++++
<html>
  <head>
    {% if title %}
    <title>{{ title }} - microblog</title>
    {% else %}
    <title>Welcome to microblog</title>
    {% endif %}
  </head>
  <body>
    <div>Microblog: <a href="/index">Home</a></div>
    <hr>
    {% block content %}{% endblock %}
  </body>
</html>
++++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In this template we use the block control statement to define the place where
  the derived templates can insert themselves. Blocks are given a unique name,
  and their content can be replaced or enhanced in derived templates.

And now what's left is to modify our index.html template to inherit from
  base.html (file app/templates/index.html):

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++++
{% extends "base.html" %}
{% block content %}
    <h1>Hi, {{ user.nickname }}!</h1>
    {% for post in posts %}
    <div><p>{{ post.author.nickname }} says: <b>{{ post.body }}</b></p></div>
    {% endfor %}
{% endblock %}
++++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Since the base.html template will now take care of the general page structure
  we have removed those elements from this one and left only the content part.
  The "extends" block establishes the inheritance link between the two templates,
  so that Jinja2 knows that when it needs to render index.html it needs to
  include it inside base.html. The two templates have matching block statements
  with name content, and this is how Jinja2 knows how to combine the two into
  one. When we get to write new templates we will also create them as
  extensions to base.html.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PART III %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Recap

In the previous chapter of the series we defined a simple template for the home
  page and used fake objects as placeholders for things we don't have yet,
  like users or blog posts.

In this article we are going to fill one of those many holes we still have in
  our app, we will be looking at how to work with web forms.

Web forms are one of the most basic building blocks in any web application. We
  will be using forms to allow users to write blog posts, and also for logging
  in to the application.

To follow this chapter along you need to have the microblog app as we left it
  at the end of the previous chapter. Please make sure the app is installed and
  running.

Configuration

To handle our web forms we are going to use the Flask-WTF extension, which in
  turn wraps the WTForms project in a way that integrates nicely with Flask
  apps.

Many Flask extensions require some amount of configuration, so we are going to
  setup a configuration file inside our root microblog folder so that it is
  easily accessible if it needs to be edited. Here is what we will start with
  (file config.py):

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++++
WTF_CSRF_ENABLED = True
SECRET_KEY = 'you-will-never-guess'
++++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Pretty simple, it's just two settings that our Flask-WTF extension needs. The
  WTF_CSRF_ENABLED setting activates the cross-site request forgery prevention
  (note that this setting is enabled by default in current versions of
  Flask-WTF). In most cases you want to have this option enabled as it makes
  your app more secure.

The SECRET_KEY setting is only needed when CSRF is enabled, and is used to
  create a cryptographic token that is used to validate a form. When you write
  your own apps make sure to set the secret key to something that is difficult
  to guess.

Now that we have our config file we need to tell Flask to read it and use it.
  We can do this right after the Flask app object is created, as follows
  (file app/__init__.py):
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
++++
from flask import Flask

app = Flask(__name__)
app.config.from_object('config')

from app import views
++++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


The user login form

Web forms are represented in Flask-WTF as classes, subclassed from base class
  Form. A form subclass simply defines the fields of the form as class
  variables.

Now we will create a login form that users will use to identify with the
  system. The login mechanism that we will support in our app is not the
  standard username/password type, we will have our users login using their
  OpenID. OpenIDs have the benefit that the authentication is done by the
  provider of the OpenID, so we don't have to validate passwords, which makes
  our site more secure to our users.

The OpenID login only requires one string, the so called OpenID. We will also
  throw a 'remember me' checkbox in the form, so that users can choose to have
  a cookie installed in their browsers that remembers their login when they
  come back.

Let's write our first form (file app/forms.py):
===============================================================================
++++
from flask_wtf import Form
from wtforms import StringField, BooleanField
from wtforms.validators import DataRequired

class LoginForm(Form):
    openid = StringField('openid', validators=[DataRequired()])
    remember_me = BooleanField('remember_me', default=False)
++++
===============================================================================

I believe the class is pretty much self-explanatory. We imported the Form
  class, and the two form field classes that we need, StringField and
  BooleanField.

The DataRequired import is a validator, a function that can be attached to a
  field to perform validation on the data submitted by the user. The
  DataRequired validator simply checks that the field is not submitted empty.
  There are many more validators included with Flask-WTF, we will use some more
  in the future.

Form templates

We will also need a template that contains the HTML that produces the form. The
  good news is that the LoginForm class that we just created knows how to render
  form fields as HTML, so we just need to concentrate on the layout. Here is
  our login template (file app/templates/login.html):

===============================================================================
++++
<!-- extend from base layout -->
{% extends "base.html" %}

{% block content %}
  <h1>Sign In</h1>
  <form action="" method="post" name="login">
      {{ form.hidden_tag() }}
      <p>
          Please enter your OpenID:<br>
          {{ form.openid(size=80) }}<br>
      </p>
      <p>{{ form.remember_me }} Remember Me</p>
      <p><input type="submit" value="Sign In"></p>
  </form>
{% endblock %}
++++
===============================================================================

Note that in this template we are reusing the base.html template through the
  extends template inheritance statement. We will actually do this with all our
  templates, to ensure a consistent layout across all pages.

There are a few interesting differences between a regular HTML form and our
  template. This template expects a form object instantiated from the form
  class we just defined stored in a template argument named form. We will take
  care of sending this template argument to the template next, when we write
  the view function that renders this template.

The form.hidden_tag() template argument will get replaced with a hidden field
  that implements the CSRF prevention that we enabled in the configuration.
  This field needs to be in all your forms if you have CSRF enabled. The good
  news is that Flask-WTF handles it for us, we just need to make sure it is
  included in the form.

The actual fields of our form are rendered by the field objects, we just need
  to refer to a {{form.field_name}} template argument in the place where each
  field should be inserted. Some fields can take arguments. In our case, we are
  asking the text field to generate our openid field with a width of 80
  characters.

Since we have not defined the submit button in the form class we have to define
  it as a regular field. The submit field does not carry any data so it doesn't
  need to be defined in the form class.

Form views

The final step before we can see our form is to code a view function that
  renders the template.

This is actually quite simple since we just need to pass a form object to the
  template. Here is our new view function (file app/views.py):

===============================================================================
++++
from flask import render_template, flash, redirect
from app import app
from .forms import LoginForm

# index view function suppressed for brevity

@app.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm()
    return render_template('login.html',
                           title='Sign In',
                           form=form)
++++
===============================================================================

So basically, we have imported our LoginForm class, instantiated an object from
  it, and sent it down to the template. This is all that is required to get
  form fields rendered.

Let's ignore for now the flash and redirect imports. We'll use them a bit later.

The only other thing that is new here is the methods argument in the route
  decorator. This tells Flask that this view function accepts GET and POST
  requests. Without this the view will only accept GET requests. We will want
  to receive the POST requests, these are the ones that will bring in the form
  data entered by the user.

At this point you can try the app and see the form in your web browser. After
  you start the application you will want to open http://localhost:5000/login
  in your web browser, as this is the route we have associated with the login
  view function.

We have not coded the part that accepts data yet, so pressing the submit button
  will not have any effect at this time.








$env:FLASK_APP = "flaskr"
